- 웹이나 HTTP도 전부 인터넷 네트워크 망에서 동작하기 때문에 HTTP 학습을 위해서는 기본적인 인터넷 통신에 대해서 알아야 한다. 클라이언트의 요청이 서버로 전달되려면 인터넷이라는 네트워크를 통과하게 된다.
그런데 어떻게 인터넷이라는 복잡한 시스템에서 클라이언트의 요청이 서버로 정확하게 전달될 수 있는걸까?
바로 인터넷 프로토콜(IP) 덕분이다. IP에서는 IP 주소라는 개념을 갖고 있으며, 이 IP 주소를 통해 복잡한 네트워크 상에서도 서로 다른 두 통신 기기 간에 식별이 가능하게 된다. 



- IP의 역할은 크게 두 가지다:
1) 원하는 IP 주소에 데이터를 전달하기
2) 데이터를 패킷이라는 통신 단위로 전달하기
데이터를 패킷이라는 통신 단위로 전달한다고 했는데, 그러면 패킷은 단지 전달할 데이터만 담고 끝나는 걸까?
아니다. 패킷은 다음의 정보들을 포함한다:
* 출발지 IP
* 목적지 IP
* 전달할 데이터
* 그 외 
중요한 건 패킷이 출발지와 목적지 IP를 갖고 있다는 사실이다.
클라이언트는 요청을 할 때 저러한 정보들을 담고 있는 패킷을 인터넷 망에 던진다.
그러면 IP 프로토콜의 여러 과정들에 의해 패킷 데이터가 목적지로 전달되는 것이다.
서버가 클라이언트로 응답을 보낼 때도 같은 시나리오다.



- 다만, IP 프로토콜만으로는 다음과 같은 한계가 있다: 
* 비연결성: 패킷이 받을 대상이 없거나 서비스 불능 상태에서도 패킷을 날려버린다.
* 비신뢰성: 패킷을 여러 개 보냈을 때, 패킷의 순서를 보장하지 못하고, 패킷 데이터가 손실되지 않도록 보장하지 못한다. 패킷이 쪼개지면 패킷 조각들이 모두 서로 같은 경로로 전송되는 것이 아니다. 서로 다른 노드를 거쳐서 전송된다는 것이다. IP 프로토콜은 단순히 먼저 도착한 순으로 패킷을 조합하기 때문에 한계가 있다.
* 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상일 때 구분하지 못한다.
이러한 IP 프로토콜의 한계를 보완해주는 것이 TCP 프로토콜이다.



- 프로토콜의 4계층
애플리케이션 계층 - HTTP, FTP
전송 계층 - TCP, UDP
인터넷 계층 - IP
네트워크 인터페이스 계층 - 랜카드, 랜드라이버



- 채팅 데이터가 전송되는 예시
1) [애플리케이션] 웹 브라우저/네트워크 게임/채팅 프로그램 등에서 메시지를 작성
2) [OS] SOCKET 라이브러리를 통해 해당 메시지가 OS로 전달
3) [OS] 메시지 데이터에 TCP 정보를 생성하여 TCP 패킷이 형성됨
4) [OS] TCP 패킷을 받아 IP 정보를 추가한 IP 패킷을 형성함
5) [네트워크 인터페이스] 이렇게 만들어진 IP 패킷에 이더넷 프레임을 씌움(MAC 주소 포함).

* IP 패킷이 생성될 때 붙는 주요 정보들: 출발지 IP, 목적지 IP 등
* TCP 패킷이 생성될 때 붙는 주요 정보들: 출발지 Port, 목적지 Port, 전송 제어 정보, 순서 정보, 검증 정보 등
이것을 보통 TCP/IP 패킷이라고 통칭해서 부른다.
TCP/IP 패킷의 이러한 정보들 덕분에 IP 프로토콜의 한계점을 보완해줄 수 있는 것이다.



- TCP의 특징
연결지향 - 3 way handshake (연결이 되었는지 서로 확인하는 절차가 있음)
데이터 전달 보증 - 데이터의 손실 여부를 알 수 있음
순서 보장 - 데이터의 순서가 올바른지 알 수 있음



- 3 way handshake 요약
SYN: 접속 요청
ACK: 요청 수락
1) 클라이언트 --> 서버로 SYN
2) 서버 --> 클라이언트로 ACK + SYN
3) 클라이언트 --> 서버로 ACK
요즘은 최적화가 되서 마지막에 ACK를 보낼 때 데이터도 함께 전송한다.
단, 클라이언트와 서버가 거쳐간 중간의 node들은 모른다.



- TCP의 순서 보장 기본적인 방식 (이는 최적화를 하지 않은 경우에 해당함)
만약 패킷을 A,B,C 순으로 보냈는데 A,C,B 순으로 도착하면
서버는 C, B 다 버리고 클라이언트에게 B부터 다시 보내도록 시킨다.



- UDP는 기능이 거의 없고 그냥 Port 정보와 체크섬 정보 등이 추가된다.
UDP의 장점은 속도이다. 그리고 최적화할 가능성이 있다. TCP는 이미 너무 많이 사용되고 있어서 건드리기 힘들다.
최근에 HTTP3가 UDP 프로토콜을 사용하면서 뜨고 있다.



- Port는 0번부터 65535번까지만 할당 가능하다.
- 0번부터 1023번까지는 잘 알려진 포트들이므로 임의로 사용하지 않는 것이 좋다.

- FTP - 20, 21
- TELNET - 23
- HTTP - 80
- HTTPS - 443



- IP는 기억하기 어렵다. 그리고 IP는 충분히 변경이 가능하다.
그래서 IP 주소를 도메인 명으로 전화해주는 게 필요했고, 그래서 나온 게 도메인 네임 시스템(Domain Name System)이다.
브라우저에 도메인명을 입력해서 접속을 시도하면 브라우저와 DNS 서버가 정보를 주고받으면서 목적지 IP로 접속이 가능하게 되는 것이다.



- URI는 Uniform Resource Identifier의 줄임말로, 인터넷 상의 리소스를 식별하는 문자열이다.
여기서 Resource는 URI로 식별할 수 있는 모든 것이 될 수 있다.
URI라는 개념은 URL과 URN을 포함하는데,
URL은 Resource Locator를 의미하고, URN은 Resource Name을 의미한다.
URL은 리소스의 위치를, URN은 리소스의 이름을 의미한다.
사실 URN은 거의 사용하지 않는다.
URN은 예를 들면 이런 방식이다
urn:isbn:8960777331 (어떤 책의 ISBN 번호)
URN 방식은 예전에 시도가 있긴 했지만 보편화에는 실패했다.
그래서 흔히 URI라고 하면 그냥 URL을 말하는 것과 다름 없다고 이해하면 된다.



- URL의 전체 문법은 다음과 같다
scheme://[userinfo@]host[:port][/path][?query][#fragment]
https://www.google.com:443/search?q=hello&hl=ko

* scheme은 보통 프로토콜을 입력한다. ex) http, https, ftp 등
* http나 https의 경우 :port 부분은 생략이 가능하다.
* userinfo@는 URL에 사용자 정보를 포함해서 인증하는 것인데, 거의 사용하지 않아 대부분 생략된다.
* host는 호스트명이라고 부르며, 도메인이나 IP주소이다. 
* /path는 리소스가 있는 경로이다. path는 개발자의 재량이 필요한 영역으로, 계층적으로 설계를 하는 것이 좋다.
ex) /home/file1.jpg
/members
/members/100
/items/iphone12
* ?query는 '쿼리 파라미터' 또는 '쿼리 스트링'이라고 부르며, key-value의 형태로 요청 데이터를 작성한다.
* #fragment는 html 내부 북마크 등에 사용하며 마찬가지로 잘 사용하지 않으며, 서버로 전송되지도 않는다.



- 웹 브라우저 요청 흐름
1) 사용자가 웹 브라우저 주소창에 https://www.google.com/search?q=hello&hl=ko 을 입력
2) DNS 서버를 통해 www.google.com 이라는 도메인명으로부터 IP 주소를 얻어냄
3) 웹 브라우저가 위 URL을 다음과 같이 변경 https://구글IP주소:443/search?q=hello&hl=ko
4) 웹 브라우저가 다음의 HTTP 요청 메시지를 생성: 
    GET /search?q=hello&hl=ko HTTP/1.1
    Host: www.google.com
5) 위에서 '채팅 데이터가 전송되는 예시'에 나온 패턴으로 요청 메시지가 서버로 전송됨.
위에서 언급한 '데이터'(body)가 바로 이 HTTP 요청 메시지이다.
6) 요청을 받은 구글 서버는 TCP/IP 패킷에 담긴 HTTP 요청 메시지를 해석해서 요청에 해당하는 HTTP 응답 메시지를 만든다.
7) 요청을 보낼 때처럼 마찬가지로 TCP/IP 패킷을 씌우고 클라이언트에 HTTP 응답 메시지를 전송한다.
8) 응답 받은 내용을 바탕으로 클라이언트의 웹 브라우저가 메시지 내용을 렌더링해서 클라이언트에게 보여준다.



- HTTP의 의미
HyperText Transfer Protocol의 약자인데, 여기서 HyperText는 html 문서를 의미한다.
원래 의미는 정말로 텍스트로 이루어진 문서를 전송하기 위한 프로토콜이었는데 이제 텍스트만 의미하지 않게 되었다.
이제는 html 뿐만 아니라 영상, 오디오, 이미지, 파일 등 모든 유형의 데이터를 HTTP 프로토콜을 통해 주고 받게 되었다.
심지어 서버 간에 통신할 때도 그냥 HTTP를 사용하는 경우도 많다.



- HTTP 버전 역사
HTTP는 원래 초기에는 GET 메서드만 지원했었고, 헤더도 없었다. 이것을 HTTP/0.9 라고 부른다.
그런데 HTTP/1.0 부터 GET 이외의 메서드들을 지원하고 헤더도 추가하게 되었다.
그리고 1997년에 나온 HTTP/1.1은 현재까지 많이 사용되고 있다.
2015년에는 HTTP/2 가 나왔고, HTTP/3는 TCP 대신에 UDP를 사용하도록 개발되고 있다.
대부분의 기능은 HTTP/1.1에 다 있고 2나 3은 성능개선에 초점이 맞추어지고 있다.
구글에서 무언가를 검색하고 개발자 도구에서 프로토콜 컬럼을 추가해서 보면 h3도 보이는데 이게 HTTP/3이다.
구글 검색은 이미 HTTP/3를 도입하고 있다는 의미이다.
네이버 검색은 아직 HTTP/2 정도까지 사용하고 있다.



- HTTP의 특징 1 : 클라이언트 - 서버 구조
쉽게 말하면 Request와 Response 구조라고 할 수 있다. 클라이언트는 서버로 Request를 보내고, 서버는 요청에 대한 결과를 만들어서 클라이언트로 Response를 보낸다는 말이다.
클라이언트와 서버라는 개념으로 통신 주체를 구분하는 게 중요한 이유는, 역할을 구분함으로써 각각이 필요한 특성들을 더 주력해서 발전시킬 수 있기 때문이다. 예를 들면 클라이언트는 요청을 하는 측이기 때문에 요청을 위한 UI/UX라든지, 요청과 관련된 성능을 개선한다든지 등에 집중하고, 서버는 응답 처리를 위한 비즈니스 로직을 개발하거나, 대용량 트래픽 처리를 위한 성능개선에 집중할 수 있게 된 것이다.



- HTTP의 특징 2 : 무상태성(Stateless)
서버가 클라이언트의 이전 상태를 보존하지 않기 때문에 이전에 주고 받은 정보가 어떤 것들인지 서버는 모른다.
그렇기 때문에 클라이언트는 요청을 보낼 때 응답을 받기 위해 필요한 데이터를 다 담아서 보내야 한다.
그 대신 무상태성에서는 응답 서버가 서로 달라도 문제가 없기 때문에 서버를 증설해도 응답 기능에 문제가 발생하지 않는다.
즉, 스케일 아웃에 유리하다. 단, 무상태성의 단점은 필요한 데이터를 다 담아 보내야 하기 때문에 전송되는 데이터의 양이 많다는 점이다.



- HTTP의 특징 3 : 비연결성(connectionless)
연결성을 가지는 예시를 들어보자. 만약 클라이언트 1,2,3이 있다고 했을 때, 세 클라이언트 모두 서버에 요청을 보내면 서버는 클라이언트 세 개 모두와 연결을 유지한다고 하자. 그렇게 되면 연결을 유지하기 위해 서버의 자원이 소모된다.
하지만 연결성을 가지지 않을 경우 요청과 응답이 이루어지면 연결이 곧바로 끊긴다.
이렇게 되면 서버 입장에서는 서버의 자원을 아낄 수 있다는 장점이 있다.
HTTP는 기본적으로 연결을 유지하지 않는 프로토콜이다. 1시간이라는 시간 동안 수 천명이 서비스를 사용한다고 해도,
서버에서 동시에 처리하는 요청은 많아봤자 수십 개 정도로 매우 적기 때문에 자원이 많이 소모되는 요청이 아닌 이상 서버의 부하가 크지 않다.
다만, 비연결성의 단점도 있다:
* TCP/IP 연결을 요청마다 새로 맺어야 한다. (각 요청마다 3-way handshake에 시간 소요)
* 웹 브라우저로 사이트를 요청하면 html만 주는 게 아니라 js, css, 추가 이미지 등 수많은 자원이 함께 다운로드된다.

HTTP 초기에는 html, js, css 등을 한꺼번에 주고 받은 게 아니라 html 따로, js 따로, css 따로 3-way handshake를 했기 때문에 더 비효율적이었다. 현재 기준으로 HTTP Persistent Connections (HTTP 지속연결)로 이러한 문제들이 어느 정도 해결되었다.
추가적으로, HTTP/2와 HTTP/3를 통해 더 많은 최적화도 이루어진 상태다.



- HTTP 메시지 요약
기본적으로 HTTP 메시지는 다음의 요소들로 구성되었다:
1) start-line (시작 라인)
2) header (헤더)
3) empty line (공백 라인. CRLF 라고 부른다. 항상 존재한다.)
4) message body (메시지 바디. 없는 경우 생략도 가능하다.)

* 요청 메시지 예시
1) GET /search?q=hello&hl=ko HTTP/1.1
2) Host: www.google.com
3) 

* 응답 메시지 예시
1) HTTP/1.1 200 OK
2) Content-Type: text/html;charset=UTF-8
   Content-Length: 3423
3) 
4) <html> ... </html>



- HTTP 메시지: start-line (시작 라인)
요청 메시지의 시작 라인은 request-line이라 부르고, 응답 메시지의 시작 라인은 status-line이라 부른다.

* 요청 메시지의 시작 라인(request-line) : "요청 라인"
request-line은 다음과 같은 내용으로 구성된다: 
    method	request-target   		HTTP-version   	CRLF(줄바꿈 공백)
    GET      	/search?q=hello&hl=ko	HTTP/1.1		
method에는 HTTP 메서드의 종류가 입력된다.
request-target은 /path와 ?query가 입력된다.

* 응답 메시지의 시작 라인(status-line) : "상태 라인"
status-line은 다음과 같은 내용으로 구성된다: 
   HTTP-version	status-code	reason-phrase	CRLF(줄바꿈 공백)
   HTTP/1.1	200		OK
reason-phrase는 이유 문구라고 부르는데, 사람이 이해할 수 있는 짧은 상태 코드 설명글이다.



- HTTP 메시지: header
헤더는 HTTP 전송에 필요한 모든 부가정보들을 담는 역할을 한다.
예를 들면 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트 브라우저 정보, 서버 애플리케이션 정보, 캐시 관리 정보 등이 있다.

헤더 필드는 다음과 같이 구성된다:
field-name: (OWS) field-value (OWS)		* OWS: 띄어쓰기 허용
* field-name key는 대소문자를 구분하지 않는다.
* field-name에 콜론(:)을 반드시 붙여서 써야 한다.

요청 메시지의 필드명과 응답 메시지의 필드명은 문법적으로는 동일한데 표준 헤드명이 많이 다르다고 보면 된다.

표준 헤더 종류는 굉장히 많으며, 필요시 임의의 헤더도 추가 가능하다. 다만 임의의 헤더를 추가하면 약속한 클라이언트와만 서로 이해할 수 있다.



- HTTP 메시지: message body
메시지 바디에는 실제 전송할 데이터가 들어있다.
HTML 문서, 이미지, 영상, JSON 등 byte로 표현 가능한 모든 데이터를 전송할 수 있다.



- HTTP의 구조는 이와 같이 매우 단순하면서도 확장성이 뛰어나다.



- API 엔드포인트 설계하기
잘못된 엔드 포인트 설계 예시를 들어보자: 
회원 목록 조회	/read-member-list
회원 조회		/read-member-by-id
회원 등록		/create-member
회원 수정		/update-member
회원 삭제		/delete-member

엔드포인트를 설계할 때는 '리소스 식별'에 유의해서 설계해야 한다.
예를 들어, '회원을 등록'하고 '수정'하고 '조회'하는 것이 리소스가 아니라 '회원'이 리소스이다.
그러므로 회원 리소스만 URI에 매핑하면 된다. 즉, 엔드 포인트를 저렇게 많이 만들 필요가 없다는 것이다.
리소스와 행위를 분리시켜야 한다.

회원 목록 조회	/members
회원 조회		/members/{id}
회원 등록		/members/{id}
회원 수정		/members/{id}
회원 삭제		/members/{id}

참고로, 계층 구조상 상위를 Collection으로 보고, 엔드포인트 작명은 복수단어(members) 사용이 권장된다.
다만, POST /orders/{orderId}/start-delivery 같은 경우처럼 Control URI 형식으로 작성되는 경우도 있다.
실무에서는 가능하면 리소스 이름으로 처리하되, 불가피할 경우 위와 같은 방식으로 작성하기도 한다.



- HTTP 메서드 종류
GET: 리소스 조회
    일반적으로 ?query를 통해 서버로 요청 데이터 전달
    메시지 바디를 사용은 가능하지만 지원하는 곳이 많지 않아서 아직은 권장되지 않음.

POST: 요청 데이터 처리. 많은 경우 신규 리소스 등록에 사용
    메시지 바디를 통해 서버로 요청 데이터 전달. 서버는 요청 데이터를 처리.
    메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능을 수행하나, 주로 신규 리소스 등록에 사용.
    POST는 어떻게 처리할지 리소스마다 따로 정하기 때문에 신규 리소스 등록이 아닐 수도 있다.
    이 외에도 POST 메서드는 다른 메서드로 처리하기 애매한 경우에 대체용으로 자주 사용된다.
    
PUT: 리소스를 대체, 해당 리소스가 없으면 생성
    리소스가 없으면 생성
    리소스가 있으면 대체(덮어쓰기)
클라이언트가 리소스의 정확한 위치(예: 리소스 id값)를 알고 URI를 지정한다는 점에서 POST와 차이가 있다.

PATCH: 리소스를 부분적으로 변경
    요청 메시지에 입력한 필드만 변경되고 입력하지 않은 필드는 기존의 값을 유지(부분 추가, 부분 수정)
    PATCH가 지원되지 않는 서버도 있다. 그런 경우 POST를 쓰면 된다.

DELETE: 리소스 삭제

HEAD: GET과 동일하지만 메시지 바디만 제외하고 반환
OPTIONS: 대상 리소스에 대한 통신 가능 옵션을 설명. 주로 CORS에서 사용
CONNECT: 대상 자원으로 식별되는 서버에 대한 터널을 설정 (거의 사용 X)
TRACE: 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행 (거의 사용 X)



- HTTP 메서드의 속성
* 안전 속성(Safe): 호출해도 리소스를 변경하지 않는지 여부를 나타내는 속성
GET, HEAD, OPTIONS, TRACE는 안전 속성이 Yes고, 나머지는 안전 속성이 No이다.

* 멱등 속성(Idempotent): 한 번 호출하든 100번 호출하든 "동일한 요청을 하면 동일한 결과가 나타나는가"를 나타내는 속성.
이 멱등성이 Yes냐 No이냐는 외부 요인에 의해 중간에 리소스가 변경되는 상황이 없다고 가정한다. 
주요 메서드 별로 생각해보자:
GET: 한 번 조회하든 두 번 조회하든 같은 결과가 조회된다. 멱등성 Yes
PUT: 결과를 대체해버리므로 같은 요청을 해도 최종 결과가 같으므로 멱등성 Yes
DELETE: 지정한 특정 리소스를 삭제하므로 같은 요청을 여러 번 해도 결과가 같으므로 멱등성 Yes
POST: 등록 요청을 할 때, 같은 요청을 해도 다른 데이터가 생성되는 것이므로 멱등성 No
멱등 속성이 No인 메서드들을 다룰 때는 특히 조심해야 하므로 적절한 수준의 의도 검증 및 제한을 걸어주는 것이 좋다.
멱등 속성이 Yes인 메서드들은 자동 복구 메커니즘을 적용시킬 수 있다. 즉, 서버가 Timeout 등으로 정상 응답을 못 주었을 때 클라이언트가 같은 요청을 다시 해도 된다는 판단 근거가 된다.

* 캐시가능 속성(Cacheable): 응답 결과를 캐시해서 사용해도 되는지 나타내는 속성
웹 브라우저에 큰 이미지를 한 번 요청한 후에 한 번 더 똑같은 이미지를 요청할 필요가 없을 것이다.
GET, HEAD, POST, PATCH는 캐시가능 속성 Yes. 현업에서는 GET, HEAD 정도만 캐시로 사용한다.
GET은 URL만 key로 잡고 캐싱하면 되지만
POST와 PATCH의 경우에는 메시지 바디까지 캐시 키로 고려해야 해서 구현이 쉽지 않다.



- 클라이언트에서 서버로 데이터 전송할 때
1) 쿼리 파라미터를 통해 데이터를 전송하는 경우
* GET
* 주로 정렬 필터(검색어)

2) 메시지 바디를 통해 데이터를 전송하는 경우
* POST, PUT, PATCH
* 회원 가입, 상품 주문, 리소스 등록, 리소스 변경 등

4가지 상황을 예시로 보자.
1) 정적 데이터 조회
일반적으로 쿼리 파라미터 없이 리소스 경로로 단순하게 조회 가능
    GET /static/star.jpg HTTP/1.1
    Host: localhost:8080

    HTTP/1.1 200 OK
    Content-Type: image/jpeg
    Content-Length: 34012

    응답 바디 내용


2) 동적 데이터 조회
쿼리 파라미터를 사용하여 데이터를 담아 GET 요청을 보내면
서버에서는 쿼리 파라미터를 기반으로 정렬 필터해서 결과를 동적으로 생성한다.
    GET /search?q=hello&hl=ko HTTP/1.1
    Host: www.google.com

동적 데이터 조회는 주로 검색, 게시판 목록에서 정렬 필터 등에 사용된다.
특히 조회 조건을 줄여주는 필터나, 조회 결과를 정렬시키는 정렬 조건에서도 주로 사용된다.


3) HTML form을 통해 데이터 전송
HTML Form 전송은 GET, POST밖에 지원하지 않는다.
POST 요청
form 태그 action="/save" method="post"
input 태그 type="text" name="username"
input 태그 type="text" name="age"
button 태그 type="submit"
이러한 기본적인 구조로 submit 버튼을 누르면
메시지 바디에 username=kim&age=20 이런 방식으로 HTTP 메시지가 작성된다.
이때, 요청 메시지 헤더의 Content-Type: application/x-www-form-urlencoded 가 붙는다.
메시지 바디에 작성된 내용은 문법적으로 쿼리 파라미터랑 비슷하다는 것을 알 수 있다.

GET 요청
만약 form 태그에 action="/members" method="get" 이라고 하면 메시지 바디에 내용이 안 들어가고
요청 라인에 /members?username=kim&age=20 HTTP/1.1 이런 식으로 입력이 들어간다.
이런 경우는 필터를 이용해서 조회를 하는 예시가 될 수 있을 것이다.

multipart/form-data 요청
form 태그 enctype="multipart/form-data"
input 태그 type="file" name="userImage"
button 태그 type="submit"
이러한 기본적인 구조로 submit 버튼을 누르면 
웹 브라우저에서 요청 HTTP 메시지를 아래와 같이 만들어준다:

POST /save HTTP/1.1
Host: localhost:8080
Content-Type: multipart/form-data; boundary=----XXX

------XXX
Content-Disposition: form-data; name="username"

kim
------XXX
Content-Disposition: form-data; name="age"

20
------XXX
Content-Disposition: form-data; name="userImage"; filename="myphoto.png"
Content-Type: image/png

12u8903090sa0909a8...
------XXX--

HTTP 메시지가 위와 같은 형태로 되는 이유는 enctype="multipart/form-data" 이 부분 때문이다.
enctype="multipart/form-data" 이 속성은 파일 업로드 같은 바이너리 데이터 전송 시 사용한다.


4) HTTP API를 통해 데이터 전송
POST /members HTTP/1.1
Content-Type: application/json

{
    "username": "kim",
    "age": 20
}

이러한 API 데이터 전송은 서버에서 서버로 전송할 때 많이 사용하고, 모바일 앱 클라이언트에서도 많이 사용한다.
React, Vue.js와 같은 웹 클라이언트와 API 통신을 할 때도 사용한다.
단, GET 요청을 할 때는 JSON보다는 일반적인 쿼리 파라미터 형태로 전송한다.
요청 메시지 헤더에서 Content-Type: application/json을 주로 사용한다. 사실상 표준이다.
옛날에는 XML도 썼지만 요즘에는 거의 JSON만 쓴다.



- API URI 엔드포인트 설계하기
엔드포인트를 설계할 때는 리소스를 식별해야지, 리소스가 아닌 다른 것을 식별하면 안 된다.
어떤 행동을 지정할지는 HTTP 메서드로 지정할 수 있기 때문이다.
그리고 리소스 별로 쿼리 파라미터를 받도록 설계해서 조회 조건을 걸어주면 더 간결하게 엔드포인트를 설계할 수 있다.
회원 목록 조회		GET	 /members
회원 등록			POST	 /members
회원 조회			GET	 /members/{id}
회원 수정			PATCH	 /members/{id}
회원 삭제			DELETE	 /members/{id}

참고로, 회원 수정은 PUT보다는 PATCH가 더 편리하다. 애매할 때는 POST 메서드를 선택하면 된다.
POST 메서드를 반드시 신규 리소스 추가에만 국한하여 생각할 필요는 없기 때문이다.

POST를 통해 신규 자원을 등록할 때, 클라이언트는 등록될 리소스의 URI를 모른다.
이 경우 서버가 새로 등록된 리소스 URI를 생성해주어야 한다.
HTTP/1.1 201 Created
Location: /members/100 
이런 식으로 말이다.
이러한 방식을 컬렉션(Collection) 방식이라고 부른다.

그런데, PUT을 통해 신규 자원을 등록하는 경우도 있다. 바로 file을 등록하는 경우이다.
파일 등록			PUT	/files/{filename}
이 경우에는 POST 때와는 달리 클라이언트에서 리소스의 URI를 알고 있어야 한다.
이런 방식을 스토어(Store) 라고 부른다. 스토어 방식은 클라이언트가 관리하는 리소스 저장소인데,
클라이언트가 리소스의 URI를 알고 관리하는 방식이다.
이 경우 스토어는 /files 라는 리소스 경로이다. 사실 이 방식은 거의 사용되지 않는다.

만약 HTML FORM 태그를 통한 API를 설계할 때는 GET과 POST밖에 지원하지 않기 때문에
명사 리소스만으로는 API 작성이 가능하지 않다. 메서드의 종류를 두 가지밖에 지원하지 않기 때문에 그런 것이다.
회원 목록 조회	GET	/members
회원 등록 폼	GET	/members/new
회원 등록	신청	POST	/members/new 또는 /members (전자가 간편함)
회원 조회		GET	/members/{id}
회원 수정 폼	GET	/members/{id}/edit
회원 수정신청	POST	/members/{id}/edit 또는 /members/{id} (전자가 간편함)
회원 삭제신청	POST	/members/{id}/delete

앞에서도 언급했지만 이러한 URI 형태를 '컨트롤 URI'라고 부른다.
이렇게, HTML FORM을 사용할 경우에는 특히나 엔드포인트에 동사를 붙인 컨트롤 URI를 사용할 수밖에 없는 경우가 많다.

URI 설계와 관련해서 참고하면 좋은 사이트
https://restfulapi.net/resource-naming
이 사이트에 보면 리소스들도 상위 리소스와 하위 리소스가 있는데 상위를 먼저 쓰고 하위를 나중에 쓴다는 내용도 있다.
ex) /customers/{customerId}/accounts/{accountId}   (번역기 돌려서 봐도 이해된다.)



- HTTP 상태코드
만약 미래에 새로운 상태 코드가 추가되어도 클라이언트를 변경하지 않아도 된다.
클라이언트가 상태코드에 대해 잘 모르더라도 해당 코드를 상위 상태코드로 해석해서 처리할 수 있다.
예를 들면 299 라는 상태코드가 있다고 하면 클라이언트는 이를 2xx 로 해석해서 처리하면 된다는 것이다.

1xx : Informational. 요청을 수신했음. 처리중임을 의미
    요청 처리중이라는 의미로, 거의 사용하지 않는다. 


2xx : Successful. 요청 정상 처리
    200 OK	   요청이 성공적으로 처리됨

    201 Created	   리소스가 정상적으로 생성됨. 주로 리소스 생성 요청할 때 사용한다.

    202 Accepted	   요청이 접수되었음. 그러나 아직 처리가 완료되지 않음. 배치 처리 같은 곳에서 주로 사용된다.
		   예를 들어, 요청 접수 후 1시간 뒤에 배치 프로세스가 요청을 처리하는 경우 등이 있다.

    204 No Content   요청이 성공적으로 처리됨. 응답 메시지 바디에 보낼 데이터가 없는 경우에 주로 사용된다.
		   보통 요청 결과 화면을 전환할 필요가 없는 경우에 사용된다.

현업에서는 200만 사용하는 경우도 있고, 200, 201, 204만 사용하는 경우도 있다.
어떤 상태코드를 사용할지는 회사마다 내부적으로 회의를 통해 정해진다.

3xx : Redirection. 요청 완료를 위해 추가 행동이 필요함을 알릴 때 사용
웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면, Location 위치로 자동으로 이동한다.
리다이렉션은 크게 세 종류가 있다:
1) 영구 리다이렉션 - 특정 리소스의 URI가 영구적으로 변동됨. 301과 308 상황에 해당한다.
    원래 URL을 사용하지 않으며, 검색 엔진 등에서도 변경을 인지하기 때문에 중요하다. 
   예)	/members	--->	/users
	/event		--->	/new-event
  
2) 일시 리다이렉션 - URI가 일시적으로 변동됨. 302, 303, 307 상황에 해당하며, 세 상태코드는 기능이 기본적으로 같다.
    일시적으로 변경하는 것이기 때문에 검색 엔진 등에서 URL을 변경하면 안 된다.
    실무에서는 매우 많이 쓰는 리다이렉션이다.
   예) 	주문 완료 후 주문 내역 화면으로 이동
	PRG 패턴: Post/Redirect/Get
POST로 주문 후에 웹 브라우저를 새로고침하면? 서버에 중복 주문이 들어갈 수도 있다.
POST로 주문 후 새로고침으로 인한 중복 주문을 방지하기 위해서는 주문 결과 화면을 GET 메서드로 리다이렉트 해야 한다.
그렇게 되면 사용자가 새로고침해도 결과 화면이 GET으로 조회되기 때문에 안전하다. 
주문 완료가 되면 서버에서 302 Found나 303 See Other를 주고 Location 헤더를 지정하여 주문 아이템 조회화면으로 보내버린다.

3) 특수 리다이렉션 - 결과 대신 캐시를 사용

4) 상태코드 설명
    300 Multiple Choices	 거의 사용 안 함

    301 Moved Permanently	 기존에 사용하던 경로를 더 이상 사용하지 않음을 알리며 리다이렉트 처리
			 서버는 Location 헤더에 새로운 경로를 입력해서 자동으로 그곳으로 이동하게 해준다.
			 물론 클라이언트 입장에서는 이 과정이 너무 빨라서 인식을 하는 경우가 별로 없다.
			 리다이렉트 시 요청 메서드가 GET 요청으로 변하고, 본문이 제거될 수 있다.
			 그러면 클라이언트는 입력했던 내용을 다시 처음부터 입력해야 한다.

    302 Found		 리다이렉트 시 요청 메서드가 GET으로 변하고 본문이 제거될 수 있다. 

    303 See Other		 302와 기능은 같다. 리다이렉트 시 요청 메서드가 무조건 GET으로 변한다.

    304 Not Modified	 캐시를 목적으로 사용한다. 클라이언트에게 리소스가 수정되지 않았음을 알려준다.
			 따라서 클라이언트는 로컬 PC에 저장된 캐시를 재사용한다. (캐시로 리다이렉트한다.)
			 304 응답은 로컬 캐시를 사용하라는 뜻이므로 응답에 메시지 바디를 포함하지 않는다.
			 주로 조건부 GET, HEAD 요청 시에 사용된다.

    307 Temporary Redirect	 302와 기능은 같다. 그런데 리다이렉트 시 요청 메서드와 본문을 반드시 유지한다.

    308 Permanent Redirect	 301과 기능이 같으나, 리다이렉트 시 요청 메서드와 본문을 그대로 유지한다는 차이가 있다.

그래서 302, 303, 307 뭘 써야하는가?
302 Found는 GET으로 '변할 수 있음'이고, 307은 메서드가 변하면 안되는 것이고, 303은 메서드가 무조건 GET으로 변한다.
303과 307이 실제로는 권장되지만 현실적으로 이미 많은 애플리케이션 라이브러리들이 302를 기본값으로 사용하고 있다.
자동 리다이렉션 시에 GET으로 변해도 되면 그냥 302를 사용해도 큰 문제는 없다.


4xx : Client Error. 클라이언트 오류로 서버가 요청을 수행할 수 없음
    400 Bad Request	 요청에 문제가 있음. 요청 파라미터가 잘못되거나 API 스펙이 맞지 않은 경우
			 백엔드에서 특히 유효성 검증을 위해 400 에러를 잘 내주어야 클라이언트 측과 오해가 없다.

    401 Unauthorized	 인증되지 않았을 때 발생하는 문제

    403 Forbidden		 서버가 요청을 이해했지만 승인하지 않았을 때.
			 주로 로그인은 했지만 접근 권한이 불충분한 경우에 발생한다.

    404 Not Found		 요청 리소스가 서버에 없는 경우 발생.
			 권한이 부족한 리소스에 접근하려 할 때 서버가 해당 리소스를 숨기려는 의도로 보내기도 한다.


5xx : Server Error. 서버 오류로 서버가 요청을 수행할 수 없음.
    500 Internal Server Error	 애매하면 500 오류

    503 Service Unavailable	 서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없음.
			 Retry-After 헤더 필드를 통해 얼마 뒤에 복구되는지 보낼 수도 있음.

    5xx 에러는 서버에 문제가 있을 때 내는 것이기 때문에 웬만해선 내면 안 된다.



- HTTP 헤더 개요
표현은 요청이나 응답에서 실제로 전달할 데이터를 의미한다.
표현 Representation = 표현 헤더 + 표현 데이터
표현 헤더는 Content-Type과 Content-Length 등이 있으며, 표현 데이터를 해석할 수 있는 정보를 제공한다.
표현 데이터는 메시지 바디에 담긴 데이터이다.
기존에는 '표현' 대신에 '엔티티'라는 용어를 썼으나, 2014년부터는 '표현'이라는 용어로 표준화되었다.
표현이라는 용어를 사용하는 이유는 말 그대로 리소스를 표현하기 때문이다.



- 표현 헤더들 Representation Headers
회원 리소스가 있다고 하자. 이 회원 리소스를 어떤 형식으로 전송할까?
html? json? xml? 리소스를 어떤 방식으로든 '표현'해야 한다. 어떤 표현 방식으로 데이터가 전송되었는지를 나타내기 위해서
HTTP 헤더에는 표현 헤더를 사용한다.
Content-Type	: 표현 데이터의 형식을 나타냄
     예)	text/html; charset=UTF-8
	application/json
	image/png
	...

Content-Encoding	: 표현 데이터의 압축 방식을 나타냄. 데이터를 전달하는 곳에서 압축 후 인코딩 헤더에 추가한다.
		 데이터를 읽는 쪽에서는 인코딩 헤더의 정보를 이용하여 압축을 해제한다.
     예)	gzip, deflate, identity (압축 안 함)

Content-Language	: 표현 데이터의 자연 언어를 나타냄
     예)	ko, en, en-US

Content-Length	: 표현 데이터의 길이를 나타냄(byte 단위)
     참고: 전송 인코딩(Transfer-Encoding)을 사용하면 Content-Length를 사용하면 안 된다.



- 협상 헤더들 Negotiation Headers
협상은 contents negotiation이라고 불리는데, 클라이언트가 선호하는 표현을 서버에 알리는 것이다.
그렇기 때문에 협상 헤더는 요청 시에만 사용된다.

Accept: 클라이언트가 선호하는 미디어 타입
Accept-Charset: 클라이언트가 선호하는 문자 인코딩
Accept-Encoding: 클라이언트가 선호하는 압축 인코딩
Accept-Language: 클라이언트가 선호하는 자연 언어



- 협상의 우선 순위 1: Quality Values q값의 크기
협상 헤더에는 q 값을 적용할 수 있다. q값은 우선 순위라고 이해할 수 있고, 0부터 1까지의 값을 가진다.
q 값을 생략하면 값이 1이 되어 우선 순위가 가장 높다.
     예)	Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
	우선순위가 높은 순으로 보면 다음과 같다: 
	ko-KR (q값 생략이므로 q=1)
	ko;q=0.9
	en-US;q=0.8
	en;q=0.7
Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7 이렇게 헤더를 적용해서 요청을 보내면 다중 언어 지원 서버일 경우 지원하는 언어들 중에 해당 언어가 있을 경우 클라이언트가 입력한 우선 순위를 우선적으로 고려해서 해당 언어로 응답해준다. 
예를 들어 개발자 도구를 켜고 google에 hello라고 검색했을 때 Headers 탭의 Request Headers 부분을 보면
Accept-Language:		ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7	
위와 같이 나와 있다. 이러한 값은 OS 설정에 의해 자동으로 적용된 것이다.



- 협상의 우선 순위 2: Accept 값의 구체성
     예)	Accept: text/*, text/plain, text/plain;format=flowed, */*
	만약 위와 같이 Accept 헤더에 네 가지의 값이 나열되어 있다.
	이런 경우 가장 구체적으로 입력한 text/plain;format=flowed 의 우선 순위가 가장 높게 매칭되서
	위 4가지를 서버에서 모두 지원한다고 가정하면 text/plain;format=flowed 방식으로 응답 메시지가 오게 된다.
	그러면 위에 맞게 우선순위 q값을 지정해주면 된다.

다음은 google 검색 창에 hello 라고 쳤을 때의 Request Headers의 Accept 헤더 값이다:
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7

text/html: HTML 형태의 웹페이지를 선호함 q=1.0 (생략)
application/xhtml+xml: XHTML 형태의 콘텐츠를 선호함 q=1.0 (생략)
application/xml;q=0.9: XML 형태의 콘텐츠를 받을 수 있음
image/avif, image/webp, image/apng: 다양한 이미지 포맷(AVIF, WebP, APNG)을 받을 수 있음 q=1.0 (생략)
*/*;q=0.8: 모든 종류의 콘텐츠를 받을 수 있으며, 우선순위 0.8
application/signed-exchange;v=b3;q=0.7: signed-exchange 형태의 콘텐츠를 받을 수 있으며, 버전 b3, 우선순위 0.7

text/html, application/xhtml+xml, image/avif, image/webp, image/apng은 모두 동일한 우선순위로
우선순위 값이 겹치는 것은 문제되지 않으며, 여러 형식을 수용할 수 있다는 의미이다.
서버는 클라이언트가 지원하는 이 형식들 중 하나를 선택하여 응답할 수 있다.



- 전송 방식과 전송 방식 헤더
전송 방식 헤더는 다음과 같은 것들이 있다: Transfer-Encoding, Range, Content-Range
전송 방식은 여러 가지가 있다:
단순 전송: Content-Length 헤더만 있음
압축 전송: Content-Encoding 헤더 필수
분할 전송: Transfer-Encoding 헤더 필수 (값 예시: chunked). 분할 전송 때는 Content-Length를 붙이면 안 된다.
범위 전송: Range 헤더 필수
	예) Range: bytes=1001-2000 (요청 헤더)
	    Content-Range: bytes 1001-2000 / 2000 (응답 헤더)



- 일반 정보 헤더
일반 정보 헤더는 단순히 정보를 제공하기 위한 목적의 헤더들이며, 특별한 기능은 없다.

From
유저 에이전트의 이메일 정보를 제공하는 헤더이다. 보안 및 프라이버시 문제로 인해 일반적인 웹 브라우저 요청에서는 거의 사용되지 않는다. 또, 검색 엔진 크롤러가 웹사이트를 크롤링할 때, 'From' 헤더를 사용하여 웹사이트 관리자에게 자신의 이메일 주소를 제공할 수 있다. 이를 통해 웹사이트 관리자는 크롤러에 문제가 있거나 크롤러를 원하지 않을 경우, 해당 이메일 주소로 연락을 취할 수 있다. 예를 들어, From 헤더에 크롤러 운영자의 이메일 주소가 포함되면, 웹사이트 관리자는 크롤링 관련 문의나 요청을 그 이메일로 보낼 수 있다.

Referer
현재 요청된 페이지의 이전 웹페이지 주소를 담는 헤더이다. 굉장히 많이 사용되는 헤더이다.
Referer를 사용해서 유입 경로를 분석할 수 있다.
실제로 관리자 도구에서도 Referer 부분을 보면서 페이지 링크를 이동해보면 확인해볼 수도 있다.
A에서 B로 이동할 때 Referer: A 헤더를 포함해서 요청을 한다.
* 참고: Referrer가 아니라 Referer이다. 영어 단어 상으로는 전자가 맞지만 오타가 나서 후자로 굳어졌다.

User-Agent
유저 에이전트의 애플리케이션 정보를 담는 헤더 (웹 브라우저 정보 등)
예) 
User-Agent:
Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36
서버 입장에서는 어떤 종류의 브라우저에서 장애가 발생하는지 파악할 때 유용하다.
또, 어떤 브라우저나 애플리케이션을 통해 요청이 들어오는지 통계 정보로도 활용할 수 있다.

Server
요청을 처리하는 ORIGIN 서버의 소프트웨어 정보로, 응답 메시지에 사용되는 헤더이다.
여기서 ORIGIN 서버란, HTTP 요청을 보내면 중간에 프록시 서버들을 거치게 되는데, 그러한 중간 서버들이 아니라		진짜 내가 요청을 받고 응답을 보내준 그 서버를 의미한다.
예)
Server: gws
Server: Apache/2.2.22 (Debian)
server: nginx 

Date
메시지가 발생한 날짜와 시간을 나타내는 헤더로, 응답 메시지에 사용된다.
예)
Date: Sat, 29 Jun 2024 14:50:07 GMT
과거에는 요청에서도 사용했었는데, 최신 스펙에서는 응답 메시지에서만 사용된다.



- 특별 정보 헤더
Host
요청 메시지에 사용되는 헤더로, 필수 헤더이며, 요청 URL의 도메인 부분이 담긴다.
여러 도메인을 처리하는 서버일 경우, 특히 Host 헤더의 필요성이 빛을 발한다.
IP 주소는 하나인데 관리하는 도메인이 여러 개이다 보니 만약 도메인을 명확하게 지정해주지 않으면 에러가 발생한다.
TCP/IP는 IP주소를 기반으로 통신을 하기 때문에 하나의 IP에 도메인이 여러 개 있는 경우에 도메인을 명확히 적어주지 않으면
서버는 자신이 관리하는 도메인 중 어떤 도메인에 해당하는 요청인지 알 수가 없다.
그렇기 때문에 Host 헤더가 필수가 된 것이다.
당연히 서버에서는 Host가 어떻게 오는가에 따라 어떻게 처리할지 준비해둔 상황이다.

Location
이미 앞에서 언급된 헤더이다.
3xx 응답 결과에 따라 Location 헤더가 있으면 해당 위치로 자동으로 이동하도록 하고,
201 Created 응답코드를 가진 응답 메시지의 경우 Location 헤더 값에 해당 리소스의 URI를 적는다. 

Allow
405 Method Not Allowed 응답 메시지에 달아주는 헤더로, 허용 가능한 HTTP 메서드들을 알려준다.
예)
Allow: GET, HEAD
많이 사용하지는 않는다.

Retry-After
503 Server Unavailable 응답코드를 가진 응답 메시지의 경우 달아주는 헤더로,
서비스가 언제부터 다시 응답해줄 수 있을지 알려준다.
날짜로 표기할 수도 있고, 초 단위 시간으로 표기해줄 수도 있다.
초 단위로 적으면 해당 시간이 지나고 나면 가능해진다는 뜻이다.
예)
Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
Retry-After: 120
 


- 인증 헤더
Authorization
클라이언트의 인증 정보를 서버에 전달
     예) Authorization: (인증 방식마다 value 입력 방식이 서로 다름)

WWW-Authenticate
리소스 접근 시 필요한 인증 방법 정의. 접근을 했는데 인증에 문제가 있을 경우,
401 Unauthorized 상태코드와 함께 응답 메시지에 사용되는 헤더이다.
인증을 위해서는 어떤 정보를 참고해야하는지 알리는 용도로 사용한다.



- 쿠키 헤더
Set-Cookie: 서버에서 클라이언트로 응답 메시지를 통해 쿠키 전달
예)
Set-Cookie: user=홍길동
--> 이 응답 메시지를 받은 클라이언트는 쿠키 저장소에 이것을 저장

Cookie: 서버로부터 받은 쿠키를 저장한 클라이언트가 HTTP 요청 시 해당 쿠키를 담아 서버에 요청
예)
Cookie: user=홍길동
이후 클라이언트는 모든 요청 메시지에 Cookie 헤더를 위와 같이 담아서 전송.
쿠키 저장소에 정보가 들어가면 이런 식으로 Cookie 헤더에 쿠키 저장소의 key-value 값들이 자동으로 포함되어 전송된다.
물론 무조건적으로 모든 웹사이트에 위와 같이 쿠키를 담아 요청하면 보안 문제가 생길 수도 있으니 제약 조건을 걸 수도 있다.



- 쿠키 제약 조건 걸기
일단 쿠키를 서버에서 셋팅을 할 때 다음과 같은 예시처럼 한다: 
set-cookie: sessionId=abcde1234; expires=Sat, 26-Dec-2020 00:00:00 GMT; path=/; domain=.google.com; Secure

쿠키의 주 사용처는 사용자 로그인 세션 관리할 때 많이 사용한다.
또, 광고 정보를 트래킹할 때도 많이 사용한다.
쿠키의 정보는 항상 서버에 전송되기 때문에 추가적인 네트워크 트래픽을 유발한다. 
그렇기 때문에 프론트엔드에서는 서버와 주고 받을 쿠키 데이터는 세션id, 인증 토큰 등 최소한으로 하고,
그 외에는 웹 스토리지(localStorage, sessionStorage)를 통해 웹 브라우저 내부에 데이터를 저장한다.
다만 주민번호, 신용카드 번호 등 보안에 민감한 데이터는 저장해서는 안 된다.



- 쿠키의 생명주기 지시어
expires 지시어
만료일을 지정하는 key로, 만료일에 도달하면 쿠키 삭제
Set-Cookie: expires=Sat, 26-Dec-2020 04:39:21 GMT

max-age 지시어
쿠키의 수명을 초 단위로 표현하며, 0이나 음수를 지정하면 쿠키 삭제
Set-Cookie: max-age=3600

expires 지시어를 생략하면 브라우저 종료 시까지만 유지되는데, 이를 '세션 쿠키'라고 한다.
max-age 지시어를 입력하면 해당 날짜까지 유지되는데, 이를 '영속 쿠키'라고 한다.

domain 지시어
domain 지시어에 도메인을 명시해주면 해당 도메인 뿐만 아니라 해당 도메인의 서브 도메인도 포함한다.
Set-Cookie: domain=example.org
예를 들면 domain=example.org 라고 domain 지시어를 지정하여 쿠키를 생성하면
example.org는 물론이고 dev.example.org 쿠키에도 쿠키를 전송한다.

만약 domain 지시어 입력을 생략하면 현재 문서 기준 도메인만 적용된다.
예를 들면 example.org에서 쿠키를 생성하고 domain 지시어에 값을 입력하지 않으면
example.org 에만 쿠키를 전송하고, dev.example.org에는 쿠키를 전송하지 않는다.



- 쿠키의 경로 지시어
path 지시어
path 지시어는 입력해준 경로를 포함한 하위 경로 페이지에만 쿠키를 전송한다.
특별한 제약 사항이 없는 일반적인 상황에서는 path=/ 와 같이 루트로 지정하여 모든 경로에 쿠키를 전송하도록 설정한다.
왜냐하면 일반적으로 한 도메인 안에서는 모든 경로에 다 전송하기를 원하는 경우가 많기 때문이다.

path=/home
/home 에 쿠키 전송
/home/level1 에 쿠키 전송
/home/level1/level2 에 쿠키 전송
/hello 쿠키 전송 불가능

path=/
/home 에 쿠키 전송
/home/level1 에 쿠키 전송
/home/level1/level2 에 쿠키 전송
/hello 에 쿠키 전송



- 보안과 관련된 쿠키 헤더 지시어(directives)
지금부터 언급하는 지시어들은 Set-Cookie를 통해 전달하는 지시어들이다.
Secure
일반적으로 쿠키는 http와 https를 구분하지 않고 전송하지만 Set-Cookie 헤더에 Secure 지시어를 추가해주면
https인 경우에만 전송한다.

HttpOnly
XSS 공격을 방지하기 위해서 추가해주는 Set-Cookie 지시어이며, 이 지시어를 걸어주면 자바스크립트 document.cookie 에서
쿠키에 접근하지 못하게 한다. HTTP 전송에만 사용한다.

SameSite
XSRF 공격을 방지하기 위해 추가해주는 Set-Cookie 지시어이며, 요청 도메인과 쿠키에 설정된 도메인이 동일한 경우에만
쿠키를 전송하도록 설정한다.
SameSite는 개발된지 오래되지 않은 기능이라 브라우저에서 어느 정도까지 지원하는지 확인하고 사용해야 한다.



- 캐시의 기본 동작 원리
만약 캐시가 없을 경우 클라이언트가 어떤 요청을 했을 때 서버가 응답을 계속 똑같이 반복하며, 모든 응답들은
처음부터 끝까지 동일한 과정을 거치게 된다. 만약 이런 방식으로 수 천 명의 요청을 수행할 경우 네트워크 트래픽 부담이 점점 가중될 것이고, 브라우저의 로딩 속도도 느려져 사용자 경험에 부정적인 영향을 줄 수 있다.

반면, 캐시를 적용하려면 일단 최초 응답 메시지의 헤더에 다음과 같은 헤더를 줘야 한다:
cache-control 헤더는 캐시와 관련된 지시어를 전달할 수 있는 헤더이며, max-age 지시어에 정수를 입력하면 해당 정수만큼의
초 단위 시간 동안 캐시가 유지된다.  
예)
cache-control: max-age=60
웹 브라우저에는 캐시를 저장하는 '캐시 저장소'가 있다.
위와 같이 적으면 해당 응답을 받은 브라우저 캐시에 60초 간 응답 메시지가 저장된다.
이후 클라이언트에서 동일한 요청을 했을 때, 먼저 캐시 유효 시간을 검증하고, 유효 시간 내에 해당한다면 
서버를 거치지 않아도 캐시에서 바로 받았던 응답 메시지를 얻어낼 수 있다.
이렇게, 캐시 가능 시간 동안에는 네트워크를 거치지 않아도 응답 메시지를 얻을 수 있다.
이렇게 되면 네트워크 비용도 줄일 수 있고 빠른 사용자 경험을 제공할 수 있다.

만약 max-age 지시어에서 지정한 시간이 지나면 어떻게 될까?
그렇게 되면 캐시 유효 시간 검증에서 처음과 똑같은 조건으로 요청을 하게 된다.
이때, 응답 메시지에는 처음과 마찬가지로 60초의 캐시 지속시간을 갱신해준다.



- 검증 헤더와 조건부 요청 1
그런데, 아무리 캐시 유효시간이 지났다고 해도 서버에서 기존 데이터를 변경하지 않았는데
똑같은 데이터를 또 다운 받는 것은 비효율적이라고 생각할 수 있다.
이 문제를 해결해줄 수 있는 것이 검증 헤더와 조건부 요청이다.

검증 헤더의 예시로 Last-Modified 헤더(응답 메시지)와 if-modified-since 헤더(요청 메시지)를 들 수 있다.
Last-Modified 헤더는 응답 메시지에 달아주는 헤더로, 해당 데이터가 마지막에 수정된 시간을 나타낸다.
예)
cache-control: max-age=60
Last-Modified: 2020년 11월 10일 10:00:00 (원래는 UTC 표기법으로 보내지만 예시라서 한글로 적었음)

이제 60초가 지났다고 하자. 이때, 클라이언트가 HTTP 요청 메시지를 보낼 때 다음과 같은 헤더도 함께 보낸다.
if-modified-since: 2020년 11월 10일 10:00:00

이 요청 메시지를 받은 서버는 응답 메시지를 보내기 전에 이 헤더의 최종수정일과 응답 데이터의 최종수정일을 비교한다. 
만약 두 날짜 값이 일치할 경우 304 Not Modified 응답코드를 보내고 메시지 바디는 비운 상태로 보낸다.
당연히 이전과 마찬가지로 Last-Modified와 cache-control도 함께 보낸다.
즉, 헤더 메타 정보만 응답해준다.
이렇게 되면 응답 메시지 바디에 데이터가 담기지 않았으므로 네트워크 트래픽이 줄어들고 속도도 더 빠른 통신이 가능하다.

304 Not Modified 응답을 받은 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신하고,
캐시 저장소로부터 데이터를 불러와서 사용하게 된다.
3xx는 리다이렉트였다고 이전에 언급했는데 이 상황에서는 캐시 저장소로 리다이렉트하라는 의미가 된다.

실제로 개발자 도구를 켜고 구글 검색창에 hello 라고 치면 Status에 글자색이 진한 게 있고 연한 게 있다.
연한 색깔은 캐시에서 불러온 것이다.
더 나아가, 해당 요소를 직접 클릭해서 새로고침해서 요청해보면 Status에 304로 뜬 것을 볼 수 있다.
그리고 Request Headers 부분에서 실제로 if-modified-since 헤더도 확인할 수 있고,
Response Headers 부분에서 Last-Modified와 cache-control: max-age 값도 확인할 수 있다.



- 검증 헤더와 조건부 요청 2
검증 헤더는 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터다.
그리고 조건부 요청 헤더는 검증 헤더로 조건에 따른 분기 처리를 하게 하는 헤더이다.

* Last-Modified와 If-Modified-Since 헤더 셋트의 단점
1초 단위로밖에 캐시 시간 조정이 불가능하다는 점이며, 날짜 기반의 로직을 사용한다는 점이다. 
데이터를 수정하면 날짜가 변경되는데, 만약 데이터를 수정했는데 데이터 결과가 똑같은 경우도 있을 것이다.
공백이나 주석을 추가하는 것도 수정은 맞지만 실제 데이터는 변하지 않는다.
그럼에도 불구하고 데이터 수정 날짜가 변경되었다는 이유로 캐시 저장소를 사용하지 못하게 되는 것이다.
또, 서버에서 캐시 로직을 날짜가 아닌 다른 기준으로 관리하고 싶을 수도 있다.
이럴 때 사용하는 게 바로 ETag와 If-None-Match 헤더 태그이다.

ETag도 Last-Modified와 같이 '검증 헤더'에 속하고, 
if-none-match는 if-modified-since와 같이 '조건부 요청 헤더'이다.

그렇다면 ETag는 조건을 만족하는 기준이 무엇일까?
ETag는 캐시용 데이터에 임의의 고유한 버전 이름을 달아주는 헤더이다.
예)
ETag: "v1.0"
ETag: "a2jiodwjekjl3"

ETag는 개발자가 임의로 부여할 수도 있고, Hash 라이브러리를 적용시킬 수도 있다.
Hash 라이브러리를 이용하면 파일을 해시 알고리즘에 넣어서 해시 알고리즘을 받을 수 있는데,
파일의 컨텐츠가 동일하면 똑같은 해시값이 나오고, 파일의 컨텐츠에 변경이 생기면 다른 해시값이 나온다.
ETag값을 임의로 부여하든 Hash 라이브러리를 이용하든 ETag 값을 데이터가 실제로 변경되어야 변경되게 하는 것이다.

Last-Modified와 If-Modified-Since는 날짜 차이를 계산해야 하는데
ETag와 If-None-Match는 동일성만 검증하는 것이다.
어찌됐든 간에 if-modified-since와 if-none-match 둘 다
true이면 200 OK  + 메시지 바디 응답을 받는 거고,
false이면 304 Not Modified 와 헤더 데이터만 응답 받는 것이다.

ETag와 If-None-Match는 단순하게 ETag만 서버에 보내서 같으면 유지, 다르면 다시 받는 원리이다.
캐시 제어 로직을 서버에서 완전히 관리할 수 있다는 장점이 있다.
또, 클라이언트는 캐시 매커니즘을모르고 단순히 이 값을 서버에 전송하기만 한다.
예를 들면 서버는 베타 오픈 기간인 3일 동안 파일이 변경되어도 ETag를 동일하게 유지할 수도 있고,
애플리케이션이 배포될 때마다 ETag를 바꾸게 할 수도 있다. 



- 캐시 제어 헤더와 지시어 정리
Cache-Control: 캐시 제어
    max-age: 캐시 유효 시간(초 단위)
    no-cache: 데이터는 캐시해도 되지만, 조건부 요청을 통해 항상 origin 서버에 검증하고 사용해야 함을 경고함.
	     origin 서버라고 한 이유는 중간에 존재하는 캐시 프록시 서버에는 하면 안 된다는 의미이다.
    no-store: 데이터에 민감한 정보가 있으므로 캐시하지 말 것 (메모리에서 사용하고 최대한 빨리 삭제)

Pragma: 캐시 제어 (Cache-Control의 하위 호환)
    no-cache: HTTP 1.0 하위호환이기 때문에 지금은 거의 사용하지 않는다.

Expires: 캐시 유효 기간(Cache-Control의 하위 호환)
    Mon, 01 Jan 1990 00:00:00 GMT
    캐시 만료일을 정확한 날짜로 지정할 수 있는 헤더.
    지금은 더 유연한 Cache-Control: max-age 사용이 권장된다. 만약 Cache-Control의 max-age 지시어가 있다면 
    Expires 헤더 자체가 무시된다.

Pragma나 Expires 헤더는 Cache-Control의 지시어로 지정할 수 있는 것들이기 때문에 하위 호환이다.



- 검증 헤더와 조건부 요청 헤더 정리
검증 헤더(Validator)
    ETag
    Last-Modified

조건부 요청 헤더
    If-None-Match: ETag 값 사용
    If-Match: ETag 값 사용(위와 반대)

    If-Modified-Since: Last-Modified 값 사용
    If-Unmodified-Since: Last-Modified 값 사용(위와 반대)



- 프록시 캐시(public 캐시)
origin 서버는 리소스의 원본이 있는 서버이자 실제 서비스를 제공해주는 서버이다.
모든 클라이언트가 origin 서버에 직접적으로 요청하고 응답을 받게 될 경우 origin 서버에 부하가 크다.
그렇기 때문에 서버는 클라이언트와 지리적으로 적절하게 가까운 위치에 프록시 캐시 서버를 개설한다.
프록시 캐시 서버를 개설한 후부터는 클라이언트의 요청들이 프록시 캐시 서버를 먼저 접근하게 된다.

특히, 유튜브를 예로 들면 사람들이 많이 찾지 않은 멀리 있는 해외 영상을 볼 경우 영상 로딩 속도가 느리지만
멀리 있는 해외 영상이어도 사람들이 많이 조회하는 영상은 로딩 속도가 빠른 건 프록시 캐시 서버 덕분이다.
이렇게 공용으로 사용하는 캐시 서버를 'public 캐시'라고 부른다.
이러한 관점에서, 우리가 흔히 말하는 개인 PC의 웹 브라우저 캐시는 'private 캐시'이다.



- Cache-Control 헤더 지시어 추가 정보
Cache-Control: public
응답이 public 캐시에 저장되어도 된다는 의미. 공용으로 사용하는 이미지나 파일 등에 적용된다.

Cache-Control: private
응답이 해당 사용자만을 위한 것임(기본값)

Cache-Control: s-maxage
프록시 캐시 서버에만 적용되는 max-age

Age: 60 (HTTP 헤더)
origin 서버에서 응답 후 프록시 캐시 내에 머문 초 단위 시간. 별로 중요하진 않음.



- 확실하게 캐시 무효화하기
간혹 Cache-Control 헤더에 no-store 지시어를 담아서 보내도
GET 요청의 경우 웹 브라우저가 임의로 캐싱을 하는 경우가 있다.
그렇기 때문에 분명하게 캐시를 무효화할 필요성을 느낄 때는 다음의 헤더 및 지시어를 전부 다 걸어줘야 한다:
 
Cache-Control: no-cache, no-store, must-revalidate
Pragma: no-cache

보통 이 정도까지만 해도 확실하게 캐싱이 되지 않게 할 수 있다.
여기서, must-revalidate 지시어는 캐시 만료 후 최초 조회 시 origin 서버에 검증해야 함을 의미한다.
그리고 원 서버 접근 실패 시 반드시 504 Gateway Timeout 상태코드를 일으켜야 한다.
must-revalidate는 캐시 유효 시간이라면 캐시를 사용한다.

그런데, no-cache는 항상 origin 서버에 검증 요청을 하고, must-revalidate는 캐시 만료 후부터 origin 서버에 검증을 하는 거라면 그냥 no-cache만 하면 되는 거 아닌가? 왜 둘 다 해야 하는가?

먼저, no-cache의 일반적인 기본 동작을 살펴볼 필요가 있다.
no-cache는 예를 들어 ETag를 물고 요청을 보낸다고 하자. 먼저 프록시 캐시 서버에 갈 것이다.
그런데 no-cache는 항상 origin 서버에 검증 요청을 해야 하기 때문에 프록시 캐시 서버에서는 origin 서버로 해당 요청을 넘겨 버린다. 그리고 origin 서버에 해당 요청이 도착하면 검증을 하고 304 Not Modified 를 프록시 캐시를 거쳐서 응답해준다.
304 응답을 받은 클라이언트는 캐시 데이터를 쓸 수 있구나 하고 캐시 데이터를 사용하게 되는 것이다.

그런데 만약 순간적으로 프록시 캐시와 원 서버 사이의 네트워크가 일시적으로 장애가 생기면 어떻게 될까?
origin 서버에 접근이 안 되고 있다는 말이다. 이럴 경우 Error 화면을 띄워야 한다고 생각할 수 있다.
하지만 에러 메시지를 보내는 것보다는 차라리 프록시 캐시 서버에서 자체적으로 200 OK 를 내서라도
origin 서버의 데이터는 아니지만 프록시 캐시에 저장되어 있는 데이터라도 보여주게 하기 위한 설정을 할 수도 있다.
이게 no-cache 지시어 정책이 돌아가고 있는 상황이다.

그런데 must-revalidate 지시어가 들어가는 상황은 어떨까?
클라이언트가 요청을 하고, 프록시 캐시에 도달한다. 그런데 캐시가 만료된 상황이다.
그러므로 origin 서버에 검증을 요청할 것이다. 그런데 네트워크가 순간적으로 단절된 상황이라면 어떨까?
이 경우에는 no-cache 때와는 달리 무조건 504 Gateway Timeout을 응답해야 한다.
즉, no-cache 때와는 달리 프록시 캐시에 있는 데이터조차 쓰지 못하게 해야 한다.
특히 은행 계좌 서버 같은 돈과 관련된 도메인에서는 특히 must-revalidate 지시어가 필요하다.

그러므로 확실하게 클라이언트가 origin 서버의 응답 데이터에만 의존하게 하려면
즉, 캐시 데이터를 조회하지 못하게 하려면 must-revalidate 지시어도 함께 넣어줘야 한다.

Pragma: no-cache 까지 보내주는 이유는 구식 브라우저 스펙도 고려해야 하기 때문이다.



- 강의를 마무리하며
* HTTP에 대해서 더 깊이있는 학습을 위해서는 RFC2616이 아닌 RFC7230 버전으로 공부할 것!

